---
title: "BBn and Sable Reference Point exploration"
author: "DK based on RM"
date: "Fall 2022"
output:
  bookdown::pdf_document2: 
    extra_dependencies: ["subfig","float"]
    citation_package: natbib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


```{r global-crap,include=F}
library(tidyverse)
library(knitr)
library(tinytex)
library(kableExtra)
library(dplyr)
library(SEBDAM)
library(ggthemes)
library(cowplot)
library(forecast)

theme_set(theme_few(base_size = 14))

# Here's where I'm sticking the figures
mod.loc <- "D:/Framework/SFA_25_26_2024/Model/"
fun.loc <-"D:/Github/Framework/RefPts/functions/"
rp.loc <- "D:/Framework/SFA_25_26_2024/RefPts/"

# Functions we need to source for this to all work
source(paste0(fun.loc,"projection_function.r"))
source(paste0(fun.loc,"Density_dependence_function.R"))
source(paste0(fun.loc,"breakpoint_function.R"))
source(paste0(fun.loc,"correlation_function.R"))


#Loading the output from TLM BBN model
tlm.select <- "1994_2022_qR_0.5"
tlm.mod <- readRDS(paste0(mod.loc,"Results/BBn/R_75_FR_90/BBn_TLM_model_output_",tlm.select,".Rds"))
pred.proc.tlm <- get_processes(tlm.mod)

tlm.mod$report$totB <- tlm.mod$report$B
tlm.mod$report$totR <- tlm.mod$report$R
tlm.mod$report$mean_m <- tlm.mod$report$m

#get_parameters(tlm.mod)
#tlm.mod$report$gI <- tlm.mod$report$g


# # If running with SEBDAM this is what ya use.
#BBn_SEAM_model_output_1994_2023_vary_m_m0_0.15_qR_0_1_10_knots.Rds
#seam.select <- "1994_2022_vary_m_m0_0.4_R0_1_15_knots"
#seam.select <- "1994_2022_vary_m_m0_1_qR_0.5_15_knots" # This has the old von B growth parameters...
#seam.select <- "1994_2022_vary_m_m0_1_qR_0.5_10_knots"
seam.select <- "1994_2022_vary_m_m0_2_qR_0.5_10_knots"
seam.mod <- readRDS(paste0(mod.loc,"Results/BBn/R_75_FR_90/BBn_SEAM_model_output_",seam.select,".Rds"))

#sm2 <- readRDS(paste0(repo_loc,"BBn_model/Results/Models/BBn_SEBDAM_model_output_1994_2022_vary_m_m0_1_R0_148_10_knots.Rds"))
#sm3 <- readRDS(paste0(repo_loc,"BBn_model/Results/Models/BBn_SEBDAM_model_output_1994_2022_vary_m_m0_1_R0_55_10_knots.Rds"))
#sm4 <- readRDS(paste0(repo_loc,"BBn_model/Results/Models/BBn_SEBDAM_model_output_1994_2022_vary_m_m0_1_R0_148_20_knots.Rds"))
#sm5 <- readRDS(paste0(repo_loc,"BBn_model/Results/Models/BBn_SEBDAM_model_output_1994_2022_vary_m_m0_1_R0_148_40_knots.Rds"))
pred.proc.seam <- get_processes(seam.mod)
seam.mod$obj$env$data$g <- seam.mod$obj$env$data$gI
seam.mod$obj$env$data$g[length(seam.mod$obj$env$data$g)+1] <- seam.mod$obj$env$data$g[length(seam.mod$obj$env$data$g)]
seam.mod$obj$env$data$gR[length(seam.mod$obj$env$data$gR)+1] <- seam.mod$obj$env$data$gR[length(seam.mod$obj$env$data$gR)]
seam.mod$report$totR <-c(seam.mod$report$totR,NA)

#get_parameters(seam.mod)

# Condition data... This isn't really necessary as I only do an acf on Condition, but whatevs.
load("Y:/Offshore/Assessment/Data/Model/2022/BBn/Model_input_mixed.RData")
cond.dat <- mod.dat$BBn %>% dplyr::select(year,CF) 
# For now we need to get a 2022 growth term (once we run the BBn model I can update this with the latest data), just recycling the growth for 2021 for the moment
cond.dat <- rbind(cond.dat,data.frame(year = 2022, CF =13.4))
#cond.dat <- cond.dat %>% dplyr::filter(year %in% 1991:2022)




```

```{r productivity-analysis,include=F}

# Setup...
num.knots <- length(seam.mod$obj$env$data$area)
years <- 1994:2023
NY <- length(years)
matYear<-c(rep(years,each=num.knots))
knots<-rep(1:num.knots,NY)



# TLM version
# prod.dat <- data.frame(Year = 1991:2022,
#                         B = tlm.mod$report$totB[-length(tlm.mod$report$totB)],
#                         R = tlm.mod$report$totR[-length(tlm.mod$report$totR)], # For some reason the SEBDAM run needs a NA at the end here.
#                         SSB = tlm.mod$report$totB[-length(tlm.mod$report$totB)] + tlm.mod$report$totR[-length(tlm.mod$report$totR)],
#                         m = tlm.mod$report$mean_m[-length(tlm.mod$report$mean_m)],
#                         g = tlm.mod$obj$env$data$g[],
#                         gR = tlm.mod$obj$env$data$gR[],
#                         CF = cond.dat$CF)
#plot.url <- paste0("D:/Github/BBn_model/Results/Figures/BBn/Ref_points/",tlm.select,"/")
### ENd TLM Productivity Data


# SEAMly version
prod.dat <- data.frame(Year = years[-length(years)],
                        B = seam.mod$report$totB[-length(seam.mod$report$totB)],
                        R = seam.mod$report$totR[-length(seam.mod$report$totR)], # For some reason the SEBDAM run needs a NA at the end here.
                        SSB = seam.mod$report$totB[-length(seam.mod$report$totB)] + seam.mod$report$totR[-length(seam.mod$report$totR)],
#                        m = seam.mod$report$mean_m[-length(seam.mod$report$mean_m)],
                        g = c(seam.mod$obj$env$data$g[-length(seam.mod$obj$env$data$g)]),
                        gR = c(seam.mod$obj$env$data$gR[-length(seam.mod$obj$env$data$g)]),
                        CF = cond.dat$CF[cond.dat$year %in% years[-length(years)]])
plot.url <- paste0(rp.loc,"Figures/BBn/R_75_FR_90/",seam.select,"/")
# The m from the SEAM model isn't a weighted mean, which is should be, so do this to get a correct m here. We also have a few options here, as you can get an m for Recruits and FR this way.


# Comparing the TLM and SEAM results, as you change the number of knots is makes increasingly more sense.
bmr <- data.frame(B=as.vector(seam.mod$report$areaB/1000),
                  m=as.vector(seam.mod$report$m),
                  R=c(as.vector(seam.mod$report$areaR/1000),rep(0,num.knots)), # Probably should be NAs for taht final year, but lets us easily get an m estimate for the projection year (only based on B)
                  Year=matYear, knotID=knots)
# Now get an m estimate for the whole area for B, R, and both, I think easiest will be to get totB and totR by year in here...
tBR <- bmr %>% group_by(Year) %>% dplyr::summarise(totB = sum(B,na.rm=T),
                                                   totR = sum(R,na.rm=T),
                                                   totSSB = sum(B,na.rm=T) + sum(R,na.rm=T))
# Now merge that with bmr...
bmr <- left_join(bmr,tBR,by="Year")

# Now getting weighted means by year should be easy...
nat.mat <- bmr %>% group_by(Year) %>% dplyr::summarise(m.FR = sum(B*m/totB,na.rm = T),
                                                       m.R  = sum(R*m/totR,na.rm=T),
                                                       m.all= sum((R+B)*m/totSSB))
nat.mat$m.seam <- seam.mod$report$mean_m

# We could use m.FR, or have separate M's here for R or FR if we wanted, several options worth discussing.
prod.dat$m <- nat.mat$m.all[-length(nat.mat$m.all)]
# Natural mortality comparison
# I also want to replace the m in the SEAM model with the weighted mean.  I don't think it's gonna make a huge difference, but it is better.
seam.mod$report$mean_m <- nat.mat$m.all
# Now make a figure showing the differences, need to pivot longer here.
nat.mat <- nat.mat[-nrow(nat.mat),] # Don't want 2023 in this...
nat.mat.long <- pivot_longer(nat.mat,-Year,names_to = "cat",values_to = "m") # or c("m.FR","m.R","m.all")
# Now make a plot to compare these.
m.comp <- ggplot(nat.mat.long,aes(x= Year,y=m,group=cat,color=cat)) + geom_point(size=3) + geom_line(linewidth=1.5) + 
                                                                      xlab("") + ylab("Natural Mortality (instantaneous)") +
                                                                      scale_y_continuous(breaks = seq(0,1,by=0.05)) + 
                                                                      scale_x_continuous(breaks = seq(1980,2025,by=5)) + 
                                                                      scale_color_manual(values = c("blue","firebrick2","grey","orange"),name = "",
                                                                                         breaks=c("m.all", "m.FR","m.R","m.seam"),
                                                                                         labels=c("Weighted", "FR","Rec","Original")) 
save_plot(paste0(plot.url,"Natural_mortality_comparison.png"),m.comp,base_height = 6,base_width = 10)                                                                      
# End the natural mortality comparison

# Explore the differences between TLM and SEAM... Note that I'm arguing for the weighted mean for natural mortality and that's what I'm using here.
two.mods <- data.frame(years = rep(years,2),model = c(rep("SEAM",NY),rep("TLM",NY)),
                       B = c(seam.mod$report$totB,tlm.mod$report$totB),
                       R = c(seam.mod$report$totR,tlm.mod$report$totR),
                       m = c(seam.mod$report$mean_m,tlm.mod$report$mean_m))

p1 <- ggplot(two.mods,aes(x=years,y = B,group=model,color=model)) + geom_line(linewidth=1.5) + 
                                                                    ylab("Biomass (tonnes)") + xlab("") +
                                                                    scale_x_continuous(breaks = seq(1980,2025,by=5)) + 
                                                                    scale_color_manual(values = c("blue","firebrick2"),guide = guide_legend(override.aes = list(alpha = 0) )) +
                                                                    theme(legend.title = element_text(color = "transparent"),
                                                                          legend.text = element_text(color = "transparent"))


p2 <- ggplot(two.mods,aes(x=years,y = R,group=model,color=model)) + geom_line(linewidth=1.5) +  
                                                                    ylab("Recruits (tonnes)") + xlab("")+
                                                                    scale_x_continuous(breaks = seq(1980,2025,by=5)) + 
                                                                    scale_color_manual(values = c("blue","firebrick2"))


p3 <- ggplot(two.mods,aes(x=years,y = m,group=model,color=model)) + geom_line(linewidth=1.5) +  
                                                                    ylab("Natural mortality (instantaneous)") + xlab("") +
                                                                    scale_x_continuous(breaks = seq(1980,2025,by=5)) + 
                                                                    scale_color_manual(values = c("blue","firebrick2"),guide = guide_legend(override.aes = list(alpha = 0) )) +
                                                                    theme(legend.title = element_text(color = "transparent"),
                                                                          legend.text = element_text(color = "transparent"))
                                                                    

p.tlm.seam <- cowplot::plot_grid(p1,p2,p3,nrow=3)
save_plot(paste0(plot.url,"SEAM_vs_TLM.png"),p.tlm.seam,base_height = 18,base_width = 10)                                                                      



# Now we can get common Recruitment data R3 assumes recruits are 3 year olds, r4 are 4 year olds etc.
prod.dat$R3 <- c(prod.dat$R[4:nrow(prod.dat)],NA,NA,NA)
prod.dat$R4 <- c(prod.dat$R[5:nrow(prod.dat)],NA,NA,NA,NA)
prod.dat$R5 <- c(prod.dat$R[6:nrow(prod.dat)],NA,NA,NA,NA,NA)
prod.dat$R6 <- c(prod.dat$R[7:nrow(prod.dat)],NA,NA,NA,NA,NA,NA)
# Assume Scallop reach recruit size at age 3, will need to check that.
prod.dat$RPS3 <- prod.dat$R3/prod.dat$SSB 
prod.dat$RPS4 <- prod.dat$R4/prod.dat$SSB 
prod.dat$RPS5 <- prod.dat$R5/prod.dat$SSB
prod.dat$RPS6 <- prod.dat$R6/prod.dat$SSB


### STEP 1, how old are recruits??
# First of all what is the likely age of recruits, for Sable we have 80-90 mm recruits, our tentative von B parameters are...
# Data is coming from ageing data in 1989, found here.... Y:\Offshore\Assessment\Data\Ageing\archive\old_ageing_from_Amy_2022\SAB height at age 1989_2.pdf 
von.B <- function(L.inf,to,K,age,R.size,FR.size) 
{
  L <- L.inf*(1-exp(-K*(age-to)))
  res <- data.frame(L = L, age=age)
  min.R <- min(abs(res$L - R.size))
  min.FR <- min(abs(res$L - FR.size))
  R.age <- res$age[which(abs(res$L - R.size) == min.R)]
  FR.age <- res$age[which(abs(res$L - FR.size) == min.FR)]
  bins <- data.frame(Age = c(R.age,FR.age), size = c(R.size,FR.size),class = c("Recruits","Fully Recruited"))
  return(res <- list(res=res,bins = bins))
}

# These are similar to the Sable parameters, primarily developed to eyeball Figure 35 in Hubley 2014 (Res Doc) where Figure 35 does not align with the value we currently use that are reported in the text.
# Going with the assumption the figure with data are correct and the text is wrong.
L.inf <- 164.4
#to <- 1.337 # So this uses a 1 year offset that we no longer believe in, going to make this 0.337 to align more with what we now do...
to <- -0.2
K <- 0.2
ages <- seq(0,15,by=0.05)
R.size = 75
FR.size = 90
res <- von.B(L.inf,to,K,ages,R.size =R.size,FR.size = FR.size)


# So here we see that 4 year olds are 77 mm 5 year olds are 90 mm, so seems like assuming recruits to be 5 years old would make sense here.
# the recruit size bin should be between 10 and 15 mm in width.
p.vb <- ggplot(res$res) + geom_line(aes(x=age,y=L),size=1.5) + scale_x_continuous(breaks = 0:max(ages), expand = c(0, 0))  + 
                          scale_y_continuous(limits = c(1,L.inf),breaks = c(seq(0,150,by=5)), expand = c(0, 0)) + 
                          xlab("Age") + ylab("Shell height (mm)") +
                          geom_segment(data = res$bins %>% dplyr::filter(class == "Recruits"), aes(x=0,y=size,xend=Age,yend=size),linetype = 'dashed',color="blue") +
                          geom_segment(data = res$bins %>% dplyr::filter(class == "Recruits"), aes(x=Age,y=1,xend=Age,yend=size),linetype = 'dashed',color="blue") +
                          geom_segment(data = res$bins %>% dplyr::filter(class == "Fully Recruited"), aes(x=0,y=size,xend=Age,yend=size),linetype = 'dashed',color="darkgreen") +
                          geom_segment(data = res$bins %>% dplyr::filter(class == "Fully Recruited"), aes(x=Age,y=1,xend=Age,yend=size),linetype = 'dashed',color="darkgreen") 
save_plot(paste0(plot.url,"von_B.png"),p.vb,base_height = 6,base_width = 10)                                                                      



# OK, so we see recruits are probably 3-4 years old based on that von B, so we could use either RPS5 or RPS6 for the density dependence 
# gonna go with the 5 year olds since I have to make a decision, so RPS5. expression(paste("Recruits per Spawner (",kg^{1},cdot,kg^{-1},")"))
# First up, let's look at the RPS time series, as we haven't before...
# This really does a bang up job of showing the dampened cycles of the recruitment patters, most interesting.
p.rps.ts <- ggplot(prod.dat, aes(x=Year,y=RPS3))  + geom_point() + 
                                                    xlab("'Birth' year") + ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9)") +
                                                    geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 7))+
                                                    scale_y_log10() +  
                                                    scale_x_continuous(breaks = c(seq(1980,2080,by=5)))# Definitely a signal here
save_plot(paste0(plot.url,"RPS_ts.png"),p.rps.ts,base_height =6,base_width = 10)                                               
                       
# Density dependence 
p.rps.ssb <- ggplot(prod.dat,aes(y=RPS3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)),size=3) + 
                                                  xlab("Spawning Stock Biomass (tonnes)") + ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9)") +
                                                  geom_smooth(method = 'lm') +
                                                  scale_y_log10() + geom_vline(xintercept = 11000,size=0.5,color='firebrick2',linetype='dashed')  + 
                                                  scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))# Definitely a signal here
save_plot(paste0(plot.url,"RPS_vs_SSB.png"),p.rps.ssb,base_height =6,base_width = 10)                                               
                       
# We could fit a 'Ricker" model to these, but you see that below 1600 tonnes there is 0 support for this kind of relationship.
# 1 could get behind using the linear model with uncertainty capping the RPS at the maximum of this linear 
#ggplot(prod.dat,aes(y=RPS3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))  + geom_smooth(method = 'lm') + scale_y_log10()  + scale_x_continuous(breaks = c(seq(1000,20000,by=500)))
#ggplot(prod.dat,aes(y=RPS3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))  + geom_smooth(method = 'lm')  + scale_x_continuous(breaks = c(seq(1000,20000,by=500)))
# One could argue for a GAM as well... this is very similar to the basic lm, but you can also see the deceleration at low Biomass with the GAM, which is pretty evident if just looking

#ggplot(prod.dat,aes(y=RPS3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))  + geom_smooth(method = 'gam') + scale_y_log10() + scale_x_continuous(breaks = c(seq(1000,20000,by=500)))
#ggplot(prod.dat,aes(y=RPS3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))  + geom_smooth(method = 'gam')  + scale_x_continuous(breaks = c(seq(1000,20000,by=500)))
# Given recruits or 5 or 6 years old, how does the 6 year old RPS look, kinda wack, might hint that recruits are not 6 years old!
#ggplot(prod.dat,aes(y=RPS6,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))  + geom_smooth(method = 'gam') + scale_y_log10() + scale_x_continuous(breaks = c(seq(1000,20000,by=500)))
#ggplot(prod.dat,aes(y=RPS6,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))  + geom_smooth(method = 'gam') + scale_x_continuous(breaks = c(seq(1000,20000,by=500)))

# It is DK's opinion that you need to look at recruitment from a 'per capita' perspective to actually understand recruitment density dependence. But you should also look at Recruits against SSB
# amd when you do that, the most parsimonous model will ALMOST always be a flat line, but worth noting that DOES MEAN there is density dependence in here, because you are getting just as
# many recruits when the population abundance is low, so a smaller SSB is able to punch out as many recruits as a high SSB, but it DOES NOT MEAN that a traditional SR model will get you anywhere useful.
p.rec.ssb <- ggplot(prod.dat,aes(y=R3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)),size=3)  +
                                                xlab("Spawning Stock Biomass (tonnes)") + ylab("Recruits (tonnes)") +
                                                geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +scale_y_log10() +
                                                geom_vline(xintercept = 11000,size=0.5,color='firebrick2',linetype='dashed')  + 
                                                scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))
save_plot(paste0(plot.url,"Rec_vs_SSB.png"),p.rec.ssb,base_height =6,base_width = 10)                                               

#ggplot(prod.dat,aes(y=R3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))  + geom_smooth(method = 'gam') + scale_x_continuous(breaks = c(seq(1000,20000,by=500)))
# So what does this tell us? DK interpretation
#1: The late 1990's is a magnificent aberation we may never see again, recruitment on BBn tends to be similar to Sab, except for during this period where recruit production was pushing 10 times normal
#2 Above 13500 tonnes there is basically 0 recruitment, less than 0.01 kg per kg of SSB
#3 Excluding 95-97 the RPS seems very consistent from 3500 tones up to 13500 tonnes 
#4 Fun thing about RPS for this set up, is that the RPS as formulated here is a direct measure of productivity, recruits in normal years contribute between 1 and 30% (except 1996 year class)
# of the biomasss entering the system.
# But what we can say is that above the maximum FR biomass RPS will tend to be low, and just below the minimum RPS should be approximately normal.  We could of course experiment
# with different 'shapes' of RPS relationship at low values in our projection function.
# So lesson here is to explore the data and come up with something that makes sense from your data. We also have to recognize that the Rec + FR does not exactly = SSB as Scallop mature at younger ages than
# we include here, but what we are interested in is the population 'recruiting' to the fishery, which included mortality on their way to becoming recruit aged and the vast majority of scallop biomas tends to be in the Rec + FR sizes.  We could do an analysis of a stock recruit model where recruits are approximately 2 years old (when we reliably see them in our gear), but that would be a different model 
# than what we have here but is something interesting worth discussion!

# Next is there any evidence of Density dependence with growth?
# There is some evidence of growth being lower at higher biomass, or at least growth not being 'high' when biomass is above around 8500-9000 tonnes
p.g.ssb <- ggplot(prod.dat,aes(y=g,x=SSB)) + geom_text(aes(label = substr(Year,3,4))) +
                                             xlab("") + ylab("Growth (Fully Recruited)") +
                                             geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                             geom_vline(xintercept = 11000,size=0.5,color='firebrick2',linetype='dashed')  + 
                                             scale_x_continuous(breaks = c(seq(1000,20000,by=1500),labels = NA))

p.gR.ssb <- ggplot(prod.dat,aes(y=gR,x=SSB)) + geom_text(aes(label = substr(Year,3,4))) +
                                             xlab("Spawning Stock Biomass (tonnes)") + ylab("Growth (Recruits)") +
                                             geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                             geom_vline(xintercept = 11000,size=0.5,color='firebrick2',linetype='dashed')  + 
                                             scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))

p.gs.ssb <-  cowplot::plot_grid(p.g.ssb,p.gR.ssb,nrow=2)

save_plot(paste0(plot.url,"Growth(FR)_vs_SSB.png"),p.gs.ssb,base_height =12,base_width = 10)                                               

# Should also look at condition vs SSB, not sure what we'd do with that for this model, but worth knowing....
# And curiously we see condition tends to be good when SSB is above 10000 tonnes (one of those it just tends not to be low  at high SSB scenarios)
p.cf.ssb <- ggplot(prod.dat,aes(y=CF,x=SSB)) + geom_text(aes(label = substr(Year,3,4))) +
                                               xlab("Spawning Stock Biomass (tonnes)") + ylab("Condition Factor (g\u22C5dm\u00B3)") +
                                               geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                               geom_vline(xintercept = 11000,size=0.5,color='firebrick2',linetype='dashed')  + 
                                               scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))
save_plot(paste0(plot.url,"Condition_vs_SSB.png"),p.cf.ssb,base_height =6,base_width = 10)                                               



# Hmm, there might be a little something here it is not really so much that m is higher than we see otherwise
# it is more m tends not to be low as often at higher biomass.  It may be a simple frequency thing, m is more likely to be low when biomass is below 10,000 or so
# and m is more likely to be in the high end of the range above 10,000.  Of course there isn't a lot of data above 10,000 so that may be over interpreting patterns.  
p.m.ssb <- ggplot(prod.dat,aes(y=m,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))+ 
                                             xlab("Spawning Stock Biomass (tonnes)") + ylab("Natural Mortality (instantaneous)") +
                                             geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                             geom_vline(xintercept = 11000,size=0.5,color='firebrick2',linetype='dashed')  + 
                                             scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))

save_plot(paste0(plot.url,"M_vs_SSB.png"),p.m.ssb,base_height =6,base_width = 10)                


# I wonder if high growth years are related to RPS, do we get higher Recruitment events after a good condition year?
# No evidence for that in general, other than 96 being a great growth year.  So could be that growth potential to get the huge spawning success, so necessary but not sufficient condition things
p.rps.g <- ggplot(prod.dat ,aes(y=RPS3,x=g)) + geom_text(aes(label = substr(Year,3,4))) + 
                                               xlab("Growth (Fully Recruited)") + ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9)") +
                                               geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                               #geom_vline(xintercept = 1.2,size=0.5,color='firebrick2',linetype='dashed') # + 
                                               scale_x_continuous(breaks = c(seq(0.8,2,by=0.1)))+ scale_y_continuous(breaks = seq(0,2,by=0.1)) 

save_plot(paste0(plot.url,"RPS_vs_Growth.png"),p.rps.g,base_height =6,base_width = 10)                

# Condition actually makes more sense to look at than growth for the density dependence in RPS, and there is nothing there whatsoever
p.rps.cf <- ggplot(prod.dat ,aes(y=RPS3,x=CF)) + geom_text(aes(label = substr(Year,3,4))) + 
                                                 xlab("Condition Factor (g\u22C5dm\u00B3)") +  ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9)") +
                                                 geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                                 #geom_vline(xintercept = 1.2,size=0.5,color='firebrick2',linetype='dashed') # + 
                                                 scale_x_continuous(breaks = c(seq(10,20,by=0.5)))  + scale_y_continuous(breaks = seq(0,2,by=0.1)) 

save_plot(paste0(plot.url,"RPS_vs_CF.png"),p.rps.cf,base_height =6,base_width = 10)                

# So there is the Density dependence analysis, For M and Growth using breakpoints makes the most sense, probably won't have a huge effect on anything 
# as there isn't a whole lot of change with SSB.  For recruits I think the bp analysis makes the most sense, but one could argue for a linear model log(R/S) ~ SSB

# Step 2.... Correlation
# Next thing you should consider is whether there are correlations in your productivity parameters, first look to autocorrelated time series
# Then you want to look for cross-correlations between mortality, recruitment, and growth, for example maybe growth is low in years when M is high
# This will matter to your simulations, so investigate it.
# First let's look for acf in our time series...
# Starting with recruitment we see there is a strong autocorrlation in the total number of recruits
p.rec.acf <- ggAcf(na.omit(prod.dat$R)) + ggtitle("")+ ylab("ACF Recruits")
save_plot(paste0(plot.url,"ACF_Rec.png"),p.rec.acf,base_height =6,base_width = 10)                

# But is this simply due to the underlying trend in R over time... no because there is no trend and it also doesn't make any difference.
rec.mod <- lm(R ~ I(Year-1993),data=prod.dat)
summary(rec.mod)
# It is not as the correlation holds
#acf(rec.mod$residuals)
# So probably better to look at per capita recruitment and see if that is a better acf'er...
# And here we do see the 1 year correlation remains.
p.rps.acf <- ggAcf(na.omit(log(prod.dat$RPS3))) + ggtitle("") + ylab("ACF log(RPS)")
save_plot(paste0(plot.url,"ACF_RPS.png"),p.rps.acf,base_height =6,base_width = 10)                

# pacf shows us that we could approximate the RPS time series as an AR2, though interesting that lag 2 is significantly negative, I think that suggest a high frequency cycling of Recruitment
# so highly correlated with the following year, then it flips 2 years out to be negative for a couple years... interesting.
p.rps.pacf <- ggPacf(na.omit(log(prod.dat$RPS3))) + ggtitle("") + ylab("PACF log(RPS)")
save_plot(paste0(plot.url,"PACF_RPS.png"),p.rps.pacf,base_height =6,base_width = 10)                
# On the log scale we see there is no trend in the data, there is a weak trend on the normal scale, but going to go with the log scale
rps.mod <- lm(log(RPS3) ~ I(Year-1993),data=prod.dat)
summary(rps.mod) # Indeed there is...
# But we see the same pattern using the residuals, just a smidge weaker, so really doesn't matter which way we go with these
# acf(rps.mod$residuals)
# pacf(rps.mod$residuals)
# rps.mod.out <- data.frame(years = 1994:2017,rps.res = rps.mod$residuals)
# ggplot(rps.mod.out,aes(x=years,y=rps.res))  + geom_text(aes(label = substr(years,3,4))) + geom_smooth(method = 'gam') + xlab("") + ylab("Recruit biomas per kg of spawners (Residual)")
# So with the recruits I think we want to set it up so that there is autocorrelation in the residuals 
# But that the mean value and variance comes from either a high or low period. Not entirely sure how to do that yet....

# Is condition or growth autocorrelated
p.cf.acf <- ggAcf(prod.dat$CF) + ggtitle("") + ylab("ACF Condition")# No autocorrelation in Condition
save_plot(paste0(plot.url,"ACF_CF.png"),p.cf.acf,base_height =6,base_width = 10)                

# How about growth, nope nothing.
p.g.acf <- ggAcf(prod.dat$g) + ggtitle("") + ylab("ACF Growth (FR)")# No autocorrelation in Condition
p.gR.acf <- ggAcf(prod.dat$gR) + ggtitle("") + ylab("ACF Growth (Recruits)")# No autocorrelation in Condition
p.gs.acf <-  cowplot::plot_grid(p.g.acf,p.gR.acf,nrow=2)

save_plot(paste0(plot.url,"ACF_growths.png"),p.gs.acf,base_height =12,base_width = 10)                

# Natural morality correlation? Yep, weak autocorrelation somewhat similar to recruitment
p.m.acf <- ggAcf(prod.dat$m) + ggtitle("") + ylab("ACF Natural Mortality") + xlab("") + scale_x_continuous(breaks = 1:14,labels=NULL) # No autocorrelation in Condition
p.m.pacf <- ggPacf(prod.dat$m) + ggtitle("") + ylab("PACF Natural Mortality")# No autocorrelation in Condition
p.m.acfs <-  cowplot::plot_grid(p.m.acf,p.m.pacf,nrow=2)
save_plot(paste0(plot.url,"ACF_m.png"),p.m.acfs,base_height =12,base_width = 10)                


# So check if there is a linear trend, and there is...
mod.m <- lm(m~I(Year-1993),data=prod.dat)
summary(mod.m) # There is a significant trend in m over time, largely due to low m in the last few years, which appears to be part of the cycling we are seeing thus I'd argue the pacf and acf above are fine.
# # So do the m residuals have acf
# m.mod.out <-  data.frame(years = 1994:2022,m.res = mod.m$residuals)
# # So the correlation in the residuals isn't significant, is absolutely still a signal there, but technically isn't significant.
# acf(m.mod.out$m.res)
# ggplot(m.mod.out,aes(x=years,y=m.res))  + geom_text(aes(label = substr(years,3,4))) + geom_smooth(method = 'gam') + xlab("") + ylab("Natural Mortality (Residual)")

# So next up lets look for evidence of correlation between your productivity parameters, specifically RPS and m

# What about other lags... Interesting that a 5 year lag shows up between mortality and RPS3.  
# I think this means when the Recruits actually show up as 'recruits' that m is high when RPS is high, and m is low when RPS is low.
prod.dat$RPS3_offset <- c(rep(NA,3),na.omit(prod.dat$RPS3[]))
ggplot(prod.dat,aes(x=Year,y=RPS3)) +geom_point() + geom_line(size=2) + geom_point(aes(y = m)) + geom_line(aes(y = m),color='blue') #+ geom_smooth(method = 'gam')
ggplot(prod.dat,aes(x=m,y=RPS3)) + geom_text(aes(label = substr(Year,3,4))) + geom_smooth(method = 'gam')
# If we offset the RPS to the year they are actually showing up, either the model is trying to kill more over everything when we have a lot of recruits, or there is a real 
# relationship there.
p.rpsoff.m <- ggplot(prod.dat,aes(x=Year,y=RPS3_offset)) + geom_text(aes(label = substr(Year-5,3,4)))  + 
                                                           xlab("") +ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9) & Natural mortality (Inst)") +
                                                           geom_line(aes(y = m),color='firebrick2',size=1,linetype='dashed')
p.rps.m.ccf <- ggCcf(prod.dat$m,prod.dat$RPS3_offset) + ggtitle("")

p.rps.m.ccf.combo <-  cowplot::plot_grid(p.rpsoff.m,p.rps.m.ccf,nrow=2)
save_plot(paste0(plot.url,"CCF_ts_RPS_offset_m.png"),p.rps.m.ccf.combo,base_height =12,base_width = 10)                
      
# How about m vs growth, nothing really, something at lag 2 and maybe some weak cycles.
# ccf(prod.dat$m,prod.dat$g)
# ccf(prod.dat$m,prod.dat$gR)
# 
# # OK, so that's m covered, what about growth and recruits, absolutely nothing.
# ccf(prod.dat$RPS3,prod.dat$g,na.action= na.omit)
# ccf(prod.dat$RPS3,prod.dat$gR,na.action= na.omit)


# For the harvest control rules we want to look at how explotation varies with biomass and also want to make the Kobe plot of Biomass vs Explotation
# So first we need to get the explotation rate
# Not 1000% sure this is correct at this point.  It is noteworth how different this is than the map though...
# The catch data
# So catches from June 2021-May 2022 are called 2021 and removed from the 2021 survey biomass (this is different indexing from how we used to handle this for offshore)
#
# SS model mu(t) <- C(t) / (B(t) + C(t)) because our model is B(t) <- B(t-1) - C(t) and C(2017) is June 2016-Aug 2017.
#  mu[2017] <- C[June 2016-Aug 2017]/(B[2017]+C[June 2016-Aug 2017]) 
# TLM and SEAM don't calculate mu, so we do it manually here, to be analogous...
# SEAM/TLM mu(t) <- C(t-1) / (B(t) + C(t-1)) because our model is B(t) <- B(t-1) - C(t-1) and C(2016) is now June 2016-Aug 2017.
# mu[2017] <- C[June 2016-Aug 2017]/(B[2017]+C[June 2016-Aug 2017]) 
catchy <- seam.mod$obj$env$data$C*seam.mod$obj$env$data$area # Get this into tonnes from catch density.
#if(mod.select == "TLM") catchy <- mod.fit$obj$env$data$C
  
pred.proc.seam$log_tot_frame$totB.LCI <- exp(pred.proc.seam$log_tot_frame$log_totB - 1.96*pred.proc.seam$log_tot_frame$se_log_totB)
pred.proc.seam$log_tot_frame$totB.UCI <- exp(pred.proc.seam$log_tot_frame$log_totB + 1.96*pred.proc.seam$log_tot_frame$se_log_totB)

# See above for explanation of how I'm doing these calculations to be consistent with the past
ann.exploit <- data.frame(year = years[-length(years)],B = exp(pred.proc.seam$log_tot_frame$log_totB)[-length(years)], Catch = colSums(catchy)[-length(years)],
                          B.LCI = pred.proc.seam$log_tot_frame$totB.LCI[-length(years)], B.UCI = pred.proc.seam$log_tot_frame$totB.UCI[-length(years)])
ann.exploit$exploit <- c(NA,ann.exploit$Catch[-nrow(ann.exploit)])/(ann.exploit$B+c(NA,ann.exploit$Catch[-nrow(ann.exploit)]))
ann.exploit$exploit.UCI <- c(NA,ann.exploit$Catch[-nrow(ann.exploit)])/(ann.exploit$B.LCI+c(NA,ann.exploit$Catch[-nrow(ann.exploit)]))
ann.exploit$exploit.LCI <- c(NA,ann.exploit$Catch[-nrow(ann.exploit)])/(ann.exploit$B.UCI+c(NA,ann.exploit$Catch[-nrow(ann.exploit)]))
ann.exploit$FM <- 1-exp(-ann.exploit$exploit)
ann.exploit$FM.LCI <- 1-exp(-ann.exploit$exploit.LCI)
ann.exploit$FM.UCI <- 1-exp(-ann.exploit$exploit.UCI)

  
ann.exploit$delta.B <- NA
ann.exploit$delta.B.per <- NA
for(i in 2:(length(years)-1)) 
{
  ann.exploit$delta.B[i] <- ann.exploit$B[i] - ann.exploit$B[i-1]
  ann.exploit$delta.B.per[i] <- (ann.exploit$B[i] - ann.exploit$B[i-1])/ ann.exploit$B[i-1] * 100
}


# Exploitation + uncertainty
#windows(11,11)
exploit.plot <- ggplot(ann.exploit) + geom_line(aes(x=year,y=exploit),size=1.5) + geom_ribbon(aes(ymin=exploit.LCI,ymax=exploit.UCI,x=year),alpha=0.5,fill='blue',color='blue') +
  xlab("") + ylab("Exploitation Rate (Proportional)") + scale_x_continuous(breaks = seq(1980,2030,by=3)) + ylim(c(0,0.35))
save_plot(paste0(plot.url,"Exploit_ts.png"),exploit.plot,base_height =12,base_width = 10)                

# Kobe plot
#windows(11,11)
kobe.plt <- ggplot(ann.exploit,aes(x=B,y=exploit)) + geom_text(aes(label=year)) +  xlim(c(0,15000)) + 
                                    annotate(geom="rect",xmin=0,xmax=8000,ymin=0.1,ymax=Inf, fill = "red", alpha=0.5)+
                                    annotate(geom="rect",xmin=8000,xmax=Inf,ymin=0,ymax=0.1, fill="green", alpha = 0.5) +
                                    annotate(geom="rect",xmin=0,xmax=8000,ymin=0,ymax=0.1, fill="gold1", alpha = 0.6) +
                                    annotate(geom="rect",xmin=8000,xmax=Inf,ymin=0.1,ymax=Inf, fill="gold1", alpha = 0.6) +
                                    geom_path(aes(y= exploit, x= B )) + 
                                    xlab("Biomass (Tonnes)") + ylab("Exploitation Rate (Proportional)") +
                                    geom_hline(yintercept = 0.1,linetype='dashed') + geom_vline(xintercept = 8000,linetype='dashed')

save_plot(paste0(plot.url,"Kobe_plot.png"),kobe.plt,base_height =12,base_width = 10)                

# Same this with LRP and USR and FMSY
# The phase plot
#windows(11,11)
phase.plt <- ggplot(ann.exploit,aes(x=B,y=exploit)) + geom_text(aes(label=year)) +  xlim(c(0,15000)) + 
                                    annotate(geom="rect",xmin=-Inf,xmax=2400,ymin=-Inf,ymax=Inf, fill = "red", alpha=0.5)+
                                    annotate(geom="rect",xmin=2400,xmax=4800,ymin=-Inf,ymax=Inf, fill="gold1", alpha = 0.5) +
                                    annotate(geom="rect",xmin=4800,xmax=Inf,ymin=-Inf,ymax=Inf, fill="green", alpha = 0.6) +                                  
                                    geom_path(aes(y= exploit, x= B )) +
                                    geom_hline(yintercept = 0.1,linetype='dashed') + geom_vline(xintercept = c(2400,4800),linetype='dashed') +
                                    xlab("Biomass (Tonnes)") + ylab("Exploitation Rate (Proportional)") 
save_plot(paste0(plot.url,"Phase_plot.png"),phase.plt,base_height =12,base_width = 10)                
    
# Now that explotation vs Biomass figure...
#windows(11,11)
ggplot(ann.exploit,aes(y=delta.B,x=exploit)) + geom_text(aes(label=year)) + geom_smooth(method='lm') +
                                          geom_hline(yintercept = 0,linetype='dashed')
                                    
   # Now that explotation vs Biomass figure... The JEM plot (Jessica's Empirical Method)....
#windows(11,11)
ggplot(ann.exploit,aes(y=delta.B.per,x=exploit)) + geom_text(aes(label=year)) + geom_smooth(method='lm') +
                                          geom_hline(yintercept = 0,linetype='dashed')   +  xlab("Exploitation") + ylab("Percent change in biomass")                             

# Again the explotation rate against biomass but without any bells and whistles, just looking for patterns...
# And there are no real strong patterns,mu might be slightly lower at abundances above 5000...
ggplot(ann.exploit,aes(x=B,y=exploit)) + geom_text(aes(label=year)) + geom_smooth(method='gam')
# So here we can use this infor to explore potential HCR's based on what the fishery has done in the past 
B.exp <- mean(ann.exploit$exploit,na.rm=T)
B.exp.2010s <- mean(ann.exploit$exploit[ann.exploit$year %in% 2011:2019],na.rm=T)
low.B.exp <- mean(ann.exploit$exploit[ann.exploit$B < 5000])
hi.B.exp <- mean(ann.exploit$exploit[ann.exploit$B >= 5000],na.rm=T)
low.B.exp <- sd(ann.exploit$exploit[ann.exploit$B < 5000])
hi.B.exp <- sd(ann.exploit$exploit[ann.exploit$B >= 5000],na.rm=T)


# So all told what's the story
# RPS is high at low biomass, but not necessarily a linear relationship, I see this more as a story of low recruitment at high biomass with highly variable recruitment at low biomass
# There is also correlation in the RPS time series and potential that we could build in 'bonanza's' in which per-capita recruitment is out of this world high.
# For natural mortality we see that m tends to be higher more frequently at high SSB than at low SSB. There is also some correlation in m with periods of higher than expect and lower than expect M.
# There's no evidence of anything particularly interesting in the growth data, no density dependence and no correlation.
# There is some correlation between m and recruitment, when recruit residuals are high so are the m residuals.  But that
# seems to be driven entirely by that 95-97 period so I don't think in a normal period there is anything interesting going on.

```



```{r productivity-simulations,include=F}

# This simulation:
# Has recruitment fixed at the median
# Estimates growth from a normal distribution based on the mean and sd of the growth time series observed in the past
# Samples the natural mortality estimate from the observed natural mortality 
# In the first year it takes the last biomass estimate and multiplies that by the exploitation rate to get a catch
# Then that value is grown/killed according to our DD model, note there is no process error in this formulation
# That formulation is below


# So the breakpoints are looking good, the linear models seem to be too 'safe', you don't get a big recruitment event ever with them
# a steady supply of recruits when maybe we shouldn't... need to look into that next.
# NOTE: I turned the process error in our model to 0, it causes big variability with no real rationale, which I don't think it great for projections.
# Notice that the population tends to 'take off' immediately in all simulations, I believe that is because average recruitment during typical SSB years
# is higher than it was from around 2012-2015, 2016 and 2017 year classes (so recruits in 2021-2022) were better recruitment years and thus we see a bit of recovery in biomass 
# in 2022 (also why the 2023 projections are quite good in the models)

# note the correlations as implmented at the moment can lead to negative recruitment, I'll need to fix that, as of June 2023 avoid using.

 # RUNME
#g.strat <- data.frame(type = "cor",strat = 'dist', bp = 9000,mn.mx = 1, sd.mx = 0.05,ar1=0,ar2=0) # The g correlation method seems to get g a bit too  high.
g.strat <- data.frame(type = "bp",strat = 'dist', bp = 1e4,mn.mx = 1, sd.mx = 0.05)
#g.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = 1, sd.mx = 0.05)
r.strat <- data.frame(type = "bp",strat = 'dist', bp = 1e4,mn.mx = 0.1*signif(min(prod.dat$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=3,
                              ar1=signif(p.rps.pacf$data$Freq[1],digits=2),ar2=signif(p.rps.pacf$data$Freq[2],digits=2),rps.m.cor = 0.75,rps.m.lag = 1) # Note lag is 1
#r.strat <- data.frame(type = "bp",strat = 'dist', bp = 13500,mn.mx = signif(min(prod.dat$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=5,
#                       ar1=0,ar2=0,rps.m.cor = 0,rps.m.lag = 0)
#r.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = signif(min(prod.dat$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=5)
m.strat <- data.frame(type = "bp",strat = 'dist', bp = 1e4,mn.mx = 2*signif(max(prod.dat$m,na.rm=T),digits=2), sd.mx = 0.1, ar1=signif(p.m.pacf$data$Freq[1],digits=2),ar2=-0) #
#m.strat <- data.frame(type = "bp",strat = 'dist', bp = 10000,mn.mx = signif(max(prod.dat$m,na.rm=T),digits=2), sd.mx = 0.1)
#m.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = signif(max(prod.dat$m,na.rm=T),digits=2), sd.mx = 0.1)
mod = "SEAM"
plot_url = "D:/Framework/SFA_25_26_2024/RefPts/Figures/BBn/R_75_FR_90/"
res_url = "D:/Framework/SFA_25_26_2024/RefPts/Results/BBn/R_75_FR_90/"

Res <- proj.mod(n_sim=500,n_y = 100,model=mod,plot_url = plot_url, run = 'model_error', res_url = res_url,save.results = T, exp.scenario=seq(0,0.24,0.01), mod.run = seam.select,
                #base.yrs = 2006:2022,
                g.mod =   list(type = g.strat$type,bp.strategy = g.strat$strat,bp= g.strat$bp, mn.at.max = g.strat$mn.mx,sd.at.max = g.strat$sd.mx),
                               #ar1=g.strat$ar1,ar2=g.strat$ar2),
                 rec.mod = list(type = r.strat$type,bp.strategy = r.strat$strat,bp= r.strat$bp, 
                                mn.at.max = r.strat$mn.mx,sd.at.max = r.strat$sd.mx,rec.age = r.strat$rec.age,rps.m.cor = r.strat$rps.m.cor,rps.m.lag = r.strat$rps.m.lag),
                                #ar1=r.strat$ar1,ar2=r.strat$ar2),
                 m.mod =   list(type = m.strat$type,bp.strategy = m.strat$strat,bp= m.strat$bp, mn.at.max = m.strat$mn.mx,sd.at.max = m.strat$sd.mx))
                                #ar1=m.strat$ar1,ar2=m.strat$ar2))
# End RUNME




```

```{r hcr-sims,include =F}

hcr.strat <-data.frame(TRP = 8300,TRP.exp = 0.175,
                       USR = 4200, USR.exp = 0.05, 
                       LRP = 2100, LRP.exp = 0,exp.sd = 0.25)
#g.strat <- data.frame(type = "cor",strat = 'dist', bp = 9000,mn.mx = 1, sd.mx = 0.05,ar1=0,ar2=0) # The g correlation method seems to get g a bit too  high.
g.strat <- data.frame(type = "bp",strat = 'dist', bp = 1e4,mn.mx = 1, sd.mx = 0.05)
#g.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = 1, sd.mx = 0.05)
r.strat <- data.frame(type = "bp",strat = 'dist', bp = 1e4,mn.mx = 0.1*signif(min(prod.dat$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=3,
                              ar1=signif(p.rps.pacf$data$Freq[1],digits=2),ar2=signif(p.rps.pacf$data$Freq[2],digits=2),rps.m.cor = 0.75,rps.m.lag = 1) # Note lag is 1
#r.strat <- data.frame(type = "bp",strat = 'dist', bp = 13500,mn.mx = signif(min(prod.dat$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=5,
#                       ar1=0,ar2=0,rps.m.cor = 0,rps.m.lag = 0)
#r.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = signif(min(prod.dat$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=5)
m.strat <- data.frame(type = "bp",strat = 'dist', bp = 1e4,mn.mx = 2*signif(max(prod.dat$m,na.rm=T),digits=2), sd.mx = 0.1, ar1=signif(p.m.pacf$data$Freq[1],digits=2),ar2=-0) #
#m.strat <- data.frame(type = "bp",strat = 'dist', bp = 10000,mn.mx = signif(max(prod.dat$m,na.rm=T),digits=2), sd.mx = 0.1)
#m.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = signif(max(prod.dat$m,na.rm=T),digits=2), sd.mx = 0.1)
mod = "SEAM"
plot_url = "D:/Framework/SFA_25_26_2024/RefPts/Figures/BBn/R_75_FR_90/"
res_url = "D:/Framework/SFA_25_26_2024/RefPts/Results/BBn/R_75_FR_90/"


# An HCR model
hcr <- proj.mod(n_sim=500,n_y = 100,model=mod,plot_url = plot_url, run = 'model_error', res_url = res_url,save.results = T,mod.run = seam.select,
                 g.mod =   list(type = g.strat$type,bp.strategy = g.strat$strat,bp= g.strat$bp, mn.at.max = g.strat$mn.mx,sd.at.max = g.strat$sd.mx,ar1=g.strat$ar1,ar2=g.strat$ar2),
                 rec.mod = list(type = r.strat$type,bp.strategy = r.strat$strat,bp= r.strat$bp, mn.at.max = r.strat$mn.mx,sd.at.max = r.strat$sd.mx,rec.age = r.strat$rec.age,
                                ar1=r.strat$ar1,ar2=r.strat$ar2,rps.m.cor = r.strat$rps.m.cor,rps.m.lag = r.strat$rps.m.lag),
                 m.mod =   list(type = m.strat$type,bp.strategy = m.strat$strat,bp= m.strat$bp, mn.at.max = m.strat$mn.mx,sd.at.max = m.strat$sd.mx,ar1=m.strat$ar1,ar2=m.strat$ar2),
                 HCR.sim = list(TRP = hcr.strat$TRP,TRP.exp = hcr.strat$TRP.exp, USR = hcr.strat$USR, USR.exp = hcr.strat$USR.exp,
                                    LRP = hcr.strat$LRP, LRP.exp = hcr.strat$LRP.exp,exp.sd = hcr.strat$exp.sd))
summary(hcr$m)
summary(prod.dat$m)
summary(hcr$g)
summary(prod.dat$g)
summary(hcr$Rec)
summary(hcr$B)
summary(hcr$rps)
summary(prod.dat$RPS3)
plot(hcr$rps[,4,1])
ccf(hcr$mort[,3,1],hcr$Rec[,3,1]) #m rps correlation

```


